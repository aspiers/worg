#+OPTIONS:    H:3 num:nil toc:2 \n:nil @:t ::t |:t ^:t -:t f:t *:t TeX:t LaTeX:t skip:nil d:(HIDE) tags:not-in-toc
#+STARTUP:    align fold nodlcheck oddeven lognotestate
#+SEQ_TODO:   TODO(t) INPROGRESS(i) WAITING(w@) | DONE(d) CANCELED(c@)
#+TAGS:       Write(w) Update(u) Fix(f) Check(c)
#+TITLE:      Org-mode outside Org-mode
#+AUTHOR:     Thorsten Jolitz
#+EMAIL:      tjolitz at gmail dot com
#+DATE        <2013-03-12 Di>
#+LANGUAGE:   en
#+PRIORITIES: A C B
#+CATEGORY:   worg

[[file:index.org][{Back to Worg's index}]]

* Introduction
  :PROPERTIES:
  :CUSTOM_ID: introduction
  :END:

  Once one gets used to Org-mode, it's hard to live without it. Even its most
  basic feature, the hierarchical tree-like structuring of files, can be
  missed badly when editing files in other GNU Emacs major-modes, not to
  mention the convenient navigation, structure-editing and visibility-cycling
  functionality Org-mode offers for these tree-like structures.

  One especially important case where Org-mode users might miss Org-mode
  functionality is their =.emacs= configuration file. These Emacs Lisp files
  might become huge, for example [[http://www.mygooglest.com/fni/dot-emacs.html][Fabrice Niessen's .emacs]] has some 9720 lines,
  and structuring them only using Emacs Lisp comments (=;=) easily becomes a
  creative nightmare (many approaches for structuring a .emacs file can be
  found on [[http://www.dotemacs.de/index.html][the very unofficial dotemacs home]] page). 

  Another typical case where Org-mode's editing facilities are missing is
  writing the comment-header sections of Emacs Lisp source code files. These
  sections often contain extensive explanations of the development-history,
  installation-process and usage of the library, but are just that - Emacs
  Lisp comment-sections. Sometimes even the comment-strings of important and
  complex Emacs Lisp functions contain long and complicated text parts that
  are not easy to edit as comments. 

  Last not least, anybody who has used =C-c C-j (org-goto)= for looking up a
  different location in the current org-file, keeping current visibility,
  might have wondered if a kind of 'remote-buffer-control' via a temporary
  indirect buffer might not be a generally useful idea.

* Org-mode everywhere
  :PROPERTIES:
  :CUSTOM_ID: org-mode-everywhere
  :END:
** File Structuring
   :PROPERTIES:
   :CUSTOM_ID: file-structuring
   :END:
*** Orgstruct 
    :PROPERTIES:
    :CUSTOM_ID: orgstruct-minor-mode
    :END:

   One possibility to enjoy Org-mode's structure-editing and list-formatting
   facilities outside Org-mode buffers is /Orgstruct minor mode/. Let's cite
   from the [[http://orgmode.org/manual/Orgstruct-mode.html][Org-mode manual]]:

#+begin_example
    If you like the intuitive way the Org mode structure editing and list
    formatting works, you might want to use these commands in other modes like
    Text mode or Mail mode as well. The minor mode orgstruct-mode makes this
    possible. [...]

    When this mode is active and the cursor is on a line that looks to Org like a
    headline or the first line of a list item, most structure editing commands
    will work, even if the same keys normally have different functionality in
    the major mode you are using. If the cursor is not in one of those special
    lines, Orgstruct mode lurks silently in the shadows. When you use
    orgstruct++-mode, Org will also export indentation and autofill settings
    into that mode, and detect item context after the first line of an item.
#+end_example

Orgstruct currently does NOT work with /outorg/ and /navi-mode/ (see below for
a description of these libraries). To make both libraries work with
orgstruct-buffers just like with outshine-buffers, it would be necessary to:

 1. Structure the file with outshine-style headings (e.g. =;; * Header=)
 2. Make Orgstruct calculate and set file-local variable =outline-regexp= the
    way /outshine/ does.
 3. Make Orgstruct calculate and set file-local variable =outline-level= the
    way /outshine/ does.
 4. Make Orgstruct calculate and set file-local variable
    =outline-promotion-headings= the way /outshine/ does. 

Then, maybe after a few minor tweaks in the libraries themselves, /outorg/ and
/navi-mode/ wouldn't care if they deal with an orgstruct-buffer or an
outshine-buffer.

*** Outline with Outshine 
    :PROPERTIES:
    :CUSTOM_ID: outline-with-outshine
    :END:

**** History and Credits
    :PROPERTIES:
    :CUSTOM_ID: history-and-credits
    :END:

/outshine/ is a merge and extension of older extensions for
/outline-minor-mode/. More exactly, /outshine/ developed out of the now
obsolete =outxxtra.el=, /Thorsten Jolitz's/ modified extension of /Per
Abrahamsen's/ =out-xtra.el=. With the blessing of it's (well-known) author
/Carsten Dominik/, /Thorsten Jolitz/ could merge the (slightly modified)
=outline-magic.el= with =outxxtra.el= and extend them into the new
=outshine.el= library. Thus, if you use outline with outshine, you don't need
outline-magic and out-xtry anymore. However, outshine does not make either of
these two libraries obsolete, since it has a more specialized approach and
might not be able to replace them in all cases.

So what is /outshine/? It's an extension library for outline-minor-mode that
gives buffers in different major-modes the 'look-and-feel' of Org-mode buffers
and enables the use of /outorg/ and /navi-mode/ on them.

To sum it up in one sentence:

#+begin_verse
 Outline with Outshine outshines Outline
#+end_verse

**** Installation
     :PROPERTIES:
     :CUSTOM_ID: outshine-installation
     :END:

Download =outshine.el= (or clone the github-repo) and copy it to a location
where Emacs can find it:

| https://github.com/tj64/outshine           |
| git clone git@github.com:tj64/outshine.git |

Use this in your '.emacs' to get started:

#+begin_src emacs-lisp
(require 'outshine)
(add-hook ‘outline-minor-mode-hook ‘outshine-hook-function)
#+end_src

Add this for Org-mode style visibility-cycling with TAB and arrow-key
structure-editing:

#+begin_src emacs-lisp
(add-hook ‘outline-minor-mode-hook
            (lambda ()
            (define-key outline-minor-mode-map
              (kbd "<tab>") 'outline-cycle)
            (define-key outline-minor-mode-map
              (kbd "<M-left>") 'outline-promote)
            (define-key outline-minor-mode-map
              (kbd "<M-right>") 'outline-demote)
            (define-key outline-minor-mode-map
              (kbd "<M-up>") 'outline-move-subtree-up)
            (define-key outline-minor-mode-map
              (kbd "<M-down>") 'outline-move-subtree-down)))
#+end_src

Add this if you (e.g.) always want outline/outshine for emacs-lisp buffers:

#+begin_src emacs-lisp
(add-hook ‘emacs-lisp-mode-hook ‘outline-minor-mode)  
#+end_src

If you want a different prefix key for outline-minor-mode, insert first:

#+begin_src emacs-lisp
 (defvar outline-minor-mode-prefix "\C-c") 
#+end_src

or whatever. The prefix can only be changed before outline (minor) mode is
loaded. /outshine/ already sets the prefix to "\C-c", replacing the
(unusable) original "\C-c @". 

**** Outshine's fundamental idea
     :PROPERTIES:
     :CUSTOM_ID: fundamental-idea
     :END:

/outshine/ is based on a very simple but powerfull idea, that enables its use
in any Emacs major-mode (in theory at least):

#+begin_verse
Outshine headlines are Org-mode headlines out-commented with =comment-region=
#+end_verse

Thus, the file at hand must be outline-structured 'the outshine way', i.e.
with the headlines being proper Org-mode headlines, marked and outcommented
with =comment-region=. As an example, to generate a 3rd level
outshine-headline in an Emacs Lisp file, write down

,-----------------------
| *** Third Level Header |
`-----------------------

mark the header line, and apply =comment-region= on it:

,-----------------------
| ;; *** Third Level Header |
`-----------------------

In a LaTeX file, an adecuate header will look like this:

,-----------------------
| % *** Third Level Header |
`-----------------------

and in a PicoLisp file like this (always depending of the major-mode specific
values of =comment-start=, =comment-end=, =comment-add= and
=comment-padding=):

,-----------------------
| ## *** Third Level Header |
`-----------------------

=outshine.el=, =outorg.el= and =navi-mode.el= are all examples of how to
structure emacs-lisp source files with outshine-style headlines. 

**** Fontification, Navigation and Structure Editing
     :PROPERTIES:
     :CUSTOM_ID: fontification-navigation-and-structure-editing
     :END:

After structuring a source code file the 'outshine-way' and loading
outline-minor-mode with outshine-extensions, the file will have a very
Org-mode like 'look-and-feel'. The headlines (up to level 8) are fontified the
same way Org-mode headlines are fontified, and the very specific navigation
and structure editing commands of outline-minor-mode as well as their more
general Org-mode style counterparts are available:

=outline-minor-mode= Minor Mode Bindings:

| key       | binding                          |
|-----------+----------------------------------|
| C-c       | PrefixCommand                    |
| <M-down>  | outline-move-subtree-down        |
| <M-left>  | outline-promote                  |
| <M-right> | outline-demote                   |
| <M-up>    | outline-move-subtree-up          |
| <tab>     | outline-cycle                    |
| C-c C-a   | show-all                         |
| C-c C-b   | outline-backward-same-level      |
| C-c C-c   | hide-entry                       |
| C-c C-d   | hide-subtree                     |
| C-c C-e   | show-entry                       |
| C-c C-f   | outline-forward-same-level       |
| C-c TAB   | show-children                    |
| C-c C-k   | show-branches                    |
| C-c C-l   | hide-leaves                      |
| C-c RET   | outline-insert-heading           |
| C-c C-n   | outline-next-visible-heading     |
| C-c C-o   | outline-hide-other               |
| C-c C-p   | outline-previous-visible-heading |
| C-c C-q   | outline-hide-sublevels           |
| C-c C-s   | show-subtree                     |
| C-c C-t   | hide-body                        |
| C-c C-u   | outline-up-heading               |
| C-c C-v   | outline-move-subtree-down        |
| C-c C-^   | outline-move-subtree-up          |
| C-c '     | outorg-edit-as-org               |
| C-c @     | outline-mark-subtree             |
| C-c I     | outline-previous-visible-heading |
| C-c J     | outline-hide-more                |
| C-c K     | outline-next-visible-heading     |
| C-c L     | outline-show-more                |
| C-c C-<   | outline-promote                  |
| C-c C->   | outline-demote                   |

** Subtree and Comment Editing
   :PROPERTIES:
   :CUSTOM_ID: comment-editing
   :END:
*** Introduction
    :PROPERTIES:
    :CUSTOM_ID: comment-editing-introduction
    :END:

    Once a (outshine) source code buffer looks and behaves like an Org-mode
    buffer, it would be nice to have the full editing power of Org-mode
    available when editing the (comment) text parts or overall structure of
    the buffer.

    Think "reverse Org-Babel": editing of comment-sections or entire subtrees
    from source code files in temporary Org-mode buffers instead of editing of
    Org-mode source-blocks in temporary source-code buffers.

    There are two new libraries available for editing with Org-mode in other
    major-modes, /outorg/ and /poporg/. Although developed independently with
    very different implementations, both libraries complement each other very
    well in their functionality. 

*** Outorg
    :PROPERTIES:
    :CUSTOM_ID: outorg
    :END:

**** Introduction and Installation
    :PROPERTIES:
    :CUSTOM_ID: outorg-introduction-and-installation
    :END:

/outorg/ is a library written by /Thorsten Jolitz/ on top of his /outshine/
library. Thus, /outorg/ needs /outshine/, and files that are structured with
outshine-style headers, otherwise it won't work. 

You can download the file (or clone the github-repo) here:

| https://github.com/tj64/outorg           |
| git clone git@github.com:tj64/outorg.git |

/outorg/ requires Org-mode too, thus should be loaded after Org-mode. Insert

#+begin_src emacs-lisp
 (require 'outorg)
#+end_src

in your .emacs and you are done. 

**** Usage
     :PROPERTIES:
     :CUSTOM_ID: outorg-usage
     :END:

/outorg's/ main command is

,------
| C-c '
`------

(C-c and single quote), used for both =outorg-edit-as-org= (as a globally
defined command in the source-code buffer) and =outorg-copy-edits-and-exit=
(in the edit-buffer, as a key defined in =outorg-edit-mode=).

Thus, with point inside a subtree or on a subtree header, pressing =C-c '
(outorg-edit-as-org)= will open this subtree in a temporary Org-mode edit
buffer, with all out-commented parts in the original buffer uncommented, and
all source code parts enclosed in Org-mode source blocks. 

With a prefix =C-u C-c '=, the whole source-code buffer will be transformed
into Org-mode and offered for editing in a temporary Org-mode buffer, all
headlines folded except the subtree where point was in. 

If the original-buffer was read-only, the user is asked if he wants to make it
writable for the Org-mode editing. If he answers yes, the buffer can be
edited, but will be set back to read-only again after editing is finished.

To avoid accidental loss of edits, the temporary outorg-edit-buffer is backed
up in the OS =/tmp= directory. During editing, the outorg-edit-buffer can be
saved as usual with =save-buffer= via  =C-x C-s=. Even when killed by
accident, that last state of the outorg-edit-buffer will be saved and can be
recovered. 

When done with editing in Org-mode, =C-c ' (C-c and single quote)= is used
again to call =outorg-copy-edits-and-exit=, a command that orderly exits the
edit-buffer by converting the (modified) comment-sections back to comments
and extracting the source-code parts out of the Org-mode source-code blocks. 

**** Outorg vs Poporg
     :PROPERTIES:
     :CUSTOM_ID: outorg-vs-poporg
     :END:

/outorg/ works on subtrees (or whole buffers). 

One advantage of this is that there is always a complete subtree (-hierarchy)
in the outorg-edit-buffer, thus not only the Orgmode editing functionality can
be applied, but also its export facilities. As an example, in order to produce
the nice README.txt files for the github-repos of /outshine/, /outorg/ and
/navi-mode/, I simply called =outorg-edit-as-org= on the first
1st-level-headline of the source-code files (the file header comment-sections)
and exported the subtree to ASCII.

One disadvantage of this is that comment-strings of (e.g. emacs-lips)
functions cannot be edited comfortably, since after transformation of the
source-code buffer they end up inside Org-mode source-code blocks - as
comment-strings, just like before. 

Enters /poporg/. It will be described in more detail in the next section, but
it can already be mentioned here that it does exactly what /outorg/ cannot do
well - Org-mode editing of atomic, isolated comment-strings, no matter where
they are found in the source code buffer. 

*** Poporg
    :PROPERTIES:
    :CUSTOM_ID: poporg
    :END:


** Remote Buffer Control
   :PROPERTIES:
   :CUSTOM_ID: remote-buffer-control
   :END:
*** Navi-mode
    :PROPERTIES:
    :CUSTOM_ID: navi-mode
    :END:
* Examples with Screenshots
  :PROPERTIES:
  :CUSTOM_ID: example-with-screenshots
  :END:
** Exploring 'outshine.el'
   :PROPERTIES:
   :CUSTOM_ID: exploring-outshine-with-navi
   :END:
** Editing and exporting subtrees
   :PROPERTIES:
   :CUSTOM_ID: editing-exporting-subtrees
   :END:
** Editing function comment-strings
   :PROPERTIES:
   :CUSTOM_ID: editing-function-comment-strings
   :END:




