#+OPTIONS:    H:3 num:nil toc:2 \n:nil @:t ::t |:t ^:{} -:t f:t *:t TeX:t LaTeX:t skip:nil d:(HIDE) tags:not-in-toc
#+STARTUP:    align fold nodlcheck hidestars oddeven lognotestate hideblocks
#+SEQ_TODO:   TODO(t) INPROGRESS(i) WAITING(w@) | DONE(d) CANCELED(c@)
#+TAGS:       Write(w) Update(u) Fix(f) Check(c) noexport(n)
#+TITLE:      iOrg - interactive Org
#+AUTHOR:     Thorsten Jolitz
#+EMAIL:      tj[at]data-driven[dot]de
#+LANGUAGE:   en
#+STYLE:      <style type="text/css">#outline-container-introduction{ clear:both; }</style>
#+LINK_UP:    index.html
#+LINK_HOME:  http://orgmode.org/worg/
#+EXPORT_EXCLUDE_TAGS: noexport

# #+name: banner
# #+begin_html
#   <div id="subtitle" style="float: center; text-align: center;">
#   <p>
#   A Web-Framework based on <a href="http://orgmode.org/">Org-mode</a> and
#                                 <a href="http://picolisp.com/5000/!wiki?home/">PicoLisp</a>
#   </p>
#   <p>
#   <a href="http://picolisp.com/5000/!wiki?home/">
#   <img src="http://picolisp.com/5000/wiki/logo.png"/>
#   </a>
#   </p>
#   </div>
# #+end_html

/iOrg -- interactive web framework built on top of Org-mode/

* Introduction
This is a sketch of a pure Org-mode and Emacs web framework with
persistence and versioning through dVCs.

The page ends with quick descriptions of a framework and a specific
application both of which makes use of these components.  There are
two choices for the development process:

  - first work on the framework and then tackle a particular
    application
  - start with a concrete goal (the particular application) and then
    abstract out the framework as part of the engineering process

Probably the most pragmatic approach is to start with some
considerations about the general architecture of the framework and
then quickly move on to the concrete goal. Otherwise, many of the more
theoretical considerations of the first phase might become obsolete
when deeper insights are gained during the work on the concrete goal.

* Languages and tools
| Emacs Lisp  | server side                                      |
| Java Script | client side                                      |
| Elnode      | web server, handles get and post requests        |
| Org-mode    | content storage both database and marked up text |
| DVCS        | data persistence and versioning                  |

* Graphical depiction of the frameworks architecture
:                                                                         Server
:                                                  +-------------------------------------------------------+
:        Client Browser                            |                                                       |
:     +-------------------+                        |  +-------------------+                                |
:     |  Static HTML      |     full pages         |  |   Emacs / Elisp   |   +---------------+  +-------+ |
:     |   Content         | <-----------------+    |  +-------------------+   | Content in    |  |  DVCS | |
:     |                   |       HTML        |    |  |          +------+ |   | flat files    |==|       | |
:     |    +--------------+                   +----+--+----------| Org  |-+-->| on file       |==|       | |
:     |    | inter-mixed  |                        |  | +------+=|      |<+---| system        |==|       | |
:     |    | interactive  |                        |  | |elnode|=+------+ |   |               |==|       | |
:     |    | JS forms,    |  JS requests get/post  |  | |      |          |   |               |  |       | |
:     |    | buttons,     | -----------------------+--+>|      |          |   +---------------+  +-------+ |
:     |    | etc...       |  form data & json      |  | +--+---+     |    |                          ^     |
:     |    |              |                        |  +----+---------+----+                          |     |
:     +----+--------------+                        |       |         |        commit changes         |     |
:                ^                                 |       |         +-------------------------------+     |
:                |           responses             |       |             checkout previous versions        |
:                +---------------------------------+-------+                                               |
:                        json or raw HTML          |                                                       |
:                                                  +-------------------------------------------------------+

* Two Use cases
Here are some use cases demonstrating how the pieces all play
together, that should shed light on the couplings displayed above.

** Change the state of a bug from TODO to DONE
First lets assume that we have a list of bugs stored in an Org-mode
document on the file system.  Each bug will be represented by a
headline with some meta-data stored in the properties, e.g.,

#+begin_src org
  ,* bugs
  ,** TODO foo doesn't work
  ,   :PROPERTIES:
  ,   :submitted-by: user-x
  ,   :assigned-to: user-y
  ,   :priority: HIGH
  ,   :ID:       515a1747-8ee1-42a7-8ca1-9a0c38844218
  ,   :END:
  ,I don't like it when =foo= doesn't work.  Here's my reproduction
  ,information...
  ,** TODO bar works too well
  ,   :PROPERTIES:
  ,   :submitted-by: user-y
  ,   :assigned-to: user-z
  ,   :priority: LOW
  ,   :ID:       cda87532-62f5-413d-a748-17bc909064f8
  ,   :END:
  ,Feature =bar= works too well and is making =foo= look bad, please stop
  ,showing off.
#+end_src

A remote user navigates to the bug listing page in her browser, the
browser requests the page from elnode, which requests the html export
of the page from Org, which reads the page from the file system,
exports to html which is then passed back to elnode which serves the
page.  Some JS is inserted into each headline adding buttons for
perform actions like changing the properties of a bug, editing its
contents etc...

The user has just completed the first bug "foo doesn't work", so she
hits the [close this bug] button.  The associated JS is run sending an
async post request to the server holding the id of the heading and the
data =state->DONE=.  Elnode parses this post request, and calls the
associated elisp function passing in the Org-id and the new state as
arguments.  This elisp function uses the Org-mode API to change the
state in the actual file on disk, it possibly also calls the
`vc-checkin' function (see vc.el) to commit the new version of the
file to the repository.

After this action is performed, Org-mode re-exports the changed
subtree to HTML.  This new HTML is returned by the function to elnode,
which sends it as a response to the async JS request.  On the browser
side the subtree holding this subtree is replaced with the new HTML
(in which the state is marked as DONE).

** View a previous version of a wiki page
A user browses to a wiki page.  The corresponding page is rendered by
Org-mode to HTML and is wrapped in a wiki-specific template either by
the Org-mode publishing system or by elnode or by some combination of
the two (the framework).

Along those items included in the wrapping template are buttons for
reverting to a previous version.  The user selects this button sending
a request to elnode.  Elnode parses this request and calls the
corresponding vc function to list recent commits with commit messages.
These are then converted to HTML by elnode (possibly with the help of
Org-mode), and are displayed to the user.

The user selects a particular commit sending a request to the server.
This request includes the commit ID.  This ID is handed to a vc
function which checks out a version of the file at that ID, hands this
file to Org-mode which exports it to HTML, which is then handed to
elnode and served to the user.

* Framework
Build a web framework which is able to abstract away all of the
boilerplate required for these components to work together allowing
application builders the freedom to focus on the logic of their
particular applications.

* Bugpile
Build a bug tracker leveraging these three components which provides
an interactive web interface bug reports stored in Org-mode files.
This would also require specifying the format of these Org-mode files
(e.g., what properties do bugs have), and writing elisp functions
which could be used outside of the framework e.g., for searching and
sorting bug reports.

