#+OPTIONS:    H:3 num:nil toc:2 \n:nil ::t |:t ^:{} -:t f:t *:t tex:t d:(HIDE) tags:not-in-toc
#+STARTUP:    align fold nodlcheck hidestars oddeven lognotestate hideblocks
#+SEQ_TODO:   TODO(t) INPROGRESS(i) WAITING(w@) | DONE(d) CANCELED(c@)
#+TAGS:       Write(w) Update(u) Fix(f) Check(c) noexport(n)
#+TITLE:      C, C++, D Source Code Blocks in Org Mode
#+AUTHOR:     Worg People, Eric Schulte, Thierry Banel, Thomas S. Dye
#+EMAIL:      schulte.eric at gmail dot com, davison at stats dot ox dot ac dot uk, tbanelwebmin at free dot fr
#+LANGUAGE:   en
#+HTML_HEAD:      <style type="text/css">#outline-container-introduction{ clear:both; }</style>
#+LINK_UP:    ../languages.html
#+LINK_HOME:  http://orgmode.org/worg/
#+EXCLUDE_TAGS: noexport

#+name: banner
#+begin_html
  <div id="subtitle" style="float: center; text-align: center;">
  <p>
  Org Mode support for
    <br><a href="http://www.gnu.org/software/gcc/">C, C++</a>
    <br><a href="http://dlang.org/">D</a>
  </p>
  <p>
  <a href="http://www.gnu.org/software/gcc/"><img src="http://www.gnu.org/software/gcc/img/gccegg-65.png"/></a>
  <a href="http://dlang.org/"><img src="http://dlang.org/images/dlogo.png"/></a>
  </p>
  </div>
#+end_html

* Template Checklist [10/12] 					   :noexport:
  - [X] Revise #+TITLE:
  - [X] Indicate #+AUTHOR:
  - [X] Add #+EMAIL:
  - [X] Revise banner source block [3/3]
    - [X] Add link to a useful language web site
    - [X] Replace "Language" with language name
    - [X] Find a suitable graphic and use it to link to the language
      web site
  - [X] Write an [[Introduction]]
  - [X] Describe [[Requirements%20and%20Setup][Requirements and Setup]]
  - [X] Replace "Language" with language name in [[Org%20Mode%20Features%20for%20Language%20Source%20Code%20Blocks][Org Mode Features for Language Source Code Blocks]]
  - [X] Describe [[Header%20Arguments][Header Arguments]]
  - [X] Describe support for [[Sessions]]
  - [ ] Describe [[Result%20Types][Result Types]]
  - [ ] Describe [[Other]] differences from supported languages
  - [X] Provide brief [[Examples%20of%20Use][Examples of Use]]
* Introduction

*Note*: this is a new version of both the software and the documentation.
It is under evaluation. Hopefully, this version will end up in
=ob-doc-C.org= and =ob-C.el=, and this file will be removed.

Babel can evaluate C, C++, and D code.

As opposed to interpreted languages, which can be evaluated directly,
C, C++, and D code is first compiled to an executable which is then
run.

If a =main= method is not present in a code block then the entire
block is wrapped in a trivial =main= function call.

Note: there used to be two separate library files, =ob-C.el= and
=ob-D.el=. They have been merged in a single =ob-C.el= file which
handle all three languages.

So, for example, the following simple code block can be evaluated and
the results of evaluation inserted into the buffer.

: #+begin_src C++ :includes <stdio.h>
:   int a=1;
:   int b=1;
:   printf("%d\n", a+b);
: #+end_src
: 
: #+results:
: : 2

** About C
C dates back in the 1970.
It was devised by Kernighan & Ritchie.
It was used to create the Unix kernel, and many of its utilities.
Today it is still the base of the Linux & Unix kernel.

** About C++
C++ was devised by Stroustrup in the 1980.
The purpose was to enhance C with object programming.
Among the features introduced by C++, there are:
  - templates and the Standard Template Library,
  - object programming, with class definition and inheritance,
  - functions and operators overloading
  - exceptions

** About D
[[http://dlang.org/][D]] is a C++-like language made by [[http://dlang.org/][Digital Mars]].
It features:
  - C++ syntax
  - Built-in garbage collector
  - Strong type system
  - Meta-programming
  - Seamless assembler support
  - Usable as a scripting language
  - C binary compatibility

* Requirements and Setup

1- You must have the compilers available on your computer.
   You may use only one of the three languages:
   there is no requirement to have all three installed.
   - C and C++ often come pre-installed.
     Popular compilers are the GNU ones, called =gcc= and =g++=.
     But others are usable as well.
   - For D, look at http://dlang.org/ for downloading and instructions.
     The compilers are called =dmd= and =rdmd=.

   Eventually, the compilers must be in the =PATH=.

2- Make any or all languages available to Babel.
   Type:
   : M-x customize-variable org-babel-load-languages
   and add the language of your choice.

* Org Mode Features for C, C++, D Source Code Blocks
** Header Arguments

- =:var VARIABLE=VALUE= ::
  A global C, C++, or D variable named VARIABLE will be declared
  and initialized with VALUE

  Possible types for VARIABLE may be:
    : int,
    : double,
    : string or const char*,
    : type[]    // type = int, double, string, const char*
    : type[][]  // type = int, double, string, const char*

  The later type, =type[][]=, is used for variables storing Org tables

  The =type[]= is used for lists or vectors declared in the header

- =:cmdline= :: command line arguments to pass to the executable
     compiled from the code block

- =:flags= :: flags to pass to the compiler

- =:main= :: can be set to "no" to inhibit wrapping of the code block
     in a =main= function call

- =:includes= (C & CC+ only):: accepts either a single string name, or a list of
     names of files to =#include= in the execution of the code block

- =:import package= (D only) ::
  An import statement will be declared in the D source before the source code

- =:defines= (C & C++ only):: just like =:includes= but for =#defines= lines at the
     top of the code

** Sessions
   There is no support for sessions

** TODO Result Types
   - Which result types are supported?
** TODO Other
   - Differences from other supported languages
* Examples of Use
** Hello World in C & C++

Here is Hello World!

#+name: c-hello
#+begin_src C :exports results
  printf ("Hello World!");
#+end_src

This source code block:

#+begin_example
#+begin_src C
  printf ("Hello World!");
#+end_src
#+end_example

** Hello World in D
Here is Hello World!

#+name: d-hello
#+begin_src D :exports results
  writefln ("Hello World!");
#+end_src

This source code block:

#+begin_example
#+begin_src D
  writefln ("Hello World!");
#+end_src
#+end_example

yields this result:

#+results: d-hello
Hello World!

Note that:
- no =main()= is declared, a trivial one is automatically provided,
- there is no directive like:
  + =#include "stdio.h"= (in C or C++)
  + =import std.stdio;= (in D)
  because those libraries are so common that they are always included.

** Scalar variables
Variables may be declared outside the script.
They are automatically inserted at the top of the script.
Three types are supported, based on the look of the value:
  - =string= or =const char*=
  - =int=
  - =double=

Example in C or C++:

#+begin_example
#+header: :var mystring="Sunday" :var myint=145 :var mydouble=3.14
#+BEGIN_SRC C
  printf ("mystring %s\n", mystring);
  printf ("myint    %d\n", myint);
  printf ("mydouble %g\n", mydouble);
#+END_SRC
#+end_example

yields this result:

#+RESULTS:
| mystring | Sunday |
| myint    |    145 |
| mydouble |   3.14 |

Example in D:

#+begin_example
#+header: :var mystring="Sunday" :var myint=145 :var mydouble=3.14
#+BEGIN_SRC D
  writefln ("mystring %s", mystring);
  writefln ("myint    %d", myint);
  writefln ("mydouble %g", mydouble);
#+END_SRC
#+end_example

yields this result:

#+RESULTS:
| mystring | Sunday |
| myint    |    145 |
| mydouble |   3.14 |

** Process an Org Mode Table

*** How to handle a table
We take an Org mode table as input, process it, and output
a new Org mode table.

This table will be input in the script, and iterated row by row:

#+tblname: somedata
| nb    | sqr | noise |
|-------+-----+-------|
| zero  |   0 |  0.23 |
| one   |   1 |  1.31 |
| two   |   4 |  4.61 |
| three |   9 |  9.05 |
| four  |  16 | 16.55 |

The table is converted to a variable in the script:
  : const char* somedata[5][3] = {...};  // in C & C++
  : string      somedata[5][3] = [...];  // in D

The header, if any, is available to the script as well:
  : const char* somedata_header[3] = { "nb", "sqr", "noise" };  // in C & C++
  : string      somedata_header[3] = { "nb", "sqr", "noise" };  // in D

The dimensions of the table are available:
  : int somedata_rows = 5;
  : int somedata_cols = 3;

Additionnally, an accessor function retrives a cell using the column
name as found in the header:
  : const char* cell = somedata_h(3,"noise"); // 9.05 in C & C++
  : string      cell = somedata_h(3,"noise"); // 9.05 in D

Note that table contents are (almost) always strings
(as opposed to integers or floating point numbers).
This allows to easily handle heterogeneous tables,
and tables with missing values.
To convert a string cell to a numeric value on the fly, use standard convertors:
  : int    cell = atoi(somedata_h(4,"sqr"));        // integer conversion in C & C++
  : double cell = atof(somedata_h(4,"noise"));      //  double conversion in C & C++
  : int    cell = to!int(somedata_h(4,"sqr"));      // integer conversion in D
  : double cell = to!double(somedata_h(4,"noise")); //  double conversion in D

*** Example in C & C++

#+name: c-table
#+header: :exports results
#+begin_src C++ :var somedata=somedata
  int main()
  {
    for (int i=0; i<somedata_rows; i++) {
      printf ("%2d %7s ", i, somedata_h(i,"nb"));
      for (int j=1; j<somedata_cols; j++) {
        const char* cell = somedata[i][j];
        printf ("%5s %5g ", cell, 1000*atof(cell));
      }
      printf("\n");
    }
    return 0;
  }
#+end_src

This code:

#+begin_example
#+header: :exports results
#+begin_src C++ :var somedata=somedata
  #include "stdlib.h"
  int main()
  {
    for (int i=0; i<somedata_rows; i++) {
      printf ("%2d ", i);
      for (int j=0; j<somedata_cols; j++) {
        const char* cell = somedata[i][j];
        printf ("%5s %5g ", cell, 1000*atof(cell));
      }
      printf("\n");
    }
    return 0;
  }
#+end_src
#+end_example

yields this result:

#+RESULTS: c-table
| 0 | zero  |  0 |     0 |  0.23 |   230 |
| 1 | one   |  1 |  1000 |  1.31 |  1310 |
| 2 | two   |  4 |  4000 |  4.61 |  4610 |
| 3 | three |  9 |  9000 |  9.05 |  9050 |
| 4 | four  | 16 | 16000 | 16.55 | 16550 |

*** Example in D

#+name: d-table
#+header: :exports results
#+begin_src D :var somedata=somedata
  void main()
  {
    foreach (i, row; somedata) {
      writef ("%2s %7s ", i, somedata_h(i,"nb"));
      foreach (j, cell; row)
        if (j) // skip 1st column
          writef ("%5s %5s ", cell, 1000*to!double(cell));
      writeln();
    }
  }
#+end_src

#+begin_example
#+begin_src D :results output :var somedata=somedata :var TT="321" :var QQ=3.14
  void main()
  {
    foreach (i, row; somedata) {
      writef ("%2s %7s ", i, somedata_h(i,"nb"));
      foreach (j, cell; row)
        if (j) // skip 1st column
          writef ("%5s %5s ", cell, 1000*to!double(cell));
      writeln();
    }
  }
#+end_src
#+end_example

yields this result:

#+results: d-table
| 0 | zero  |  0 |     0 |  0.23 |   230 |
| 1 | one   |  1 |  1000 |  1.31 |  1310 |
| 2 | two   |  4 |  4000 |  4.61 |  4610 |
| 3 | three |  9 |  9000 |  9.05 |  9050 |
| 4 | four  | 16 | 16000 | 16.55 | 16550 |


*** Pure numeric table

This table is a pure numeric table.
| 3 | 3.3 |
| 4 | 4.1 |
| 5 | 5.9 |
| 6 | 6.5 |

In this special case, it is translated to a numeric table:
: double MyTable[4][2] = { {3,3.3}, {4,4.1}, {5,5.9}, {6,6.5} };

If there is a blank cell among numeric cells,
then the whole table falls back to the string case,
where the blank cell is translated to the empty string "".

** TODO Lists and vectors in the header
* New version

Here is a new version of =ob-C.el=.
Compared to the version in the repository, this one adds a few features:
- non-homogeneous tables
- table headers support
- easier table iterating
- some error handling enhancement
- new D support for simple lists and vectors
- temporary block expansion

#+BEGIN_SRC elisp :results none
;;; ob-C.el --- org-babel functions for C and similar languages

;; Copyright (C) 2010-2014 Free Software Foundation, Inc.

;; Author: Eric Schulte, Thierry Banel
;; Keywords: literate programming, reproducible research
;; Homepage: http://orgmode.org

;; This file is part of GNU Emacs.

;; GNU Emacs is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; GNU Emacs is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; Org-Babel support for evaluating C, C++, D code.
;;
;; very limited implementation:
;; - currently only support :results output
;; - not much in the way of error feedback

;;; Code:
(require 'ob)
(require 'cc-mode)
(eval-when-compile
  (require 'cl))

(declare-function org-entry-get "org"
		  (pom property &optional inherit literal-nil))
(declare-function org-remove-indentation "org" (code &optional n))

(defvar org-babel-tangle-lang-exts)
(add-to-list 'org-babel-tangle-lang-exts '("C++" . "cpp"))
(add-to-list 'org-babel-tangle-lang-exts '("D" . "d"))

(defvar org-babel-default-header-args:C '())

(defvar org-babel-C-compiler "gcc"
  "Command used to compile a C source code file into an
executable.")

(defvar org-babel-C++-compiler "g++"
  "Command used to compile a C++ source code file into an
executable.")

(defvar org-babel-D-compiler "rdmd"
  "Command used to compile and execute a D source code file.")

(defvar org-babel-c-variant nil
  "Internal variable used to hold which type of C (e.g. C or C++ or D)
is currently being evaluated.")

(defun org-babel-execute:cpp (body params)
  "Execute BODY according to PARAMS.
This function calls `org-babel-execute:C++'."
  (org-babel-execute:C++ body params))

(defun org-babel-execute:C++ (body params)
  "Execute a block of C++ code with org-babel.
This function is called by `org-babel-execute-src-block'."
  (let ((org-babel-c-variant 'cpp)) (org-babel-C-execute body params)))

(defun org-babel-execute:D (body params)
  "Execute a block of D code with org-babel.
This function is called by `org-babel-execute-src-block'."
  (let ((org-babel-c-variant 'd)) (org-babel-C-execute body params)))

(defun org-babel-execute:C (body params)
  "Execute a block of C code with org-babel.
This function is called by `org-babel-execute-src-block'."
  (let ((org-babel-c-variant 'c)) (org-babel-C-execute body params)))

(defun org-babel-C-execute (body params)
  "This function should only be called by `org-babel-execute:C'
or `org-babel-execute:C++' or `org-babel-execute:D'."
  (let* ((tmp-src-file (org-babel-temp-file
			"C-src-"
			(case org-babel-c-variant
			 (c   ".c"  )
			 (cpp ".cpp")
			 (d   ".d"  ))))
	 (tmp-bin-file (org-babel-temp-file "C-bin-" org-babel-exeext)) ;; not used for D
	 (cmdline (cdr (assoc :cmdline params)))
	 (cmdline (if cmdline (concat " " cmdline) ""))
	 (flags (cdr (assoc :flags params)))
	 (flags (mapconcat 'identity
			   (if (listp flags) flags (list flags)) " "))
	 (full-body
	  (case org-babel-c-variant
	    (c   (org-babel-C-expand-C   body params))
	    (cpp (org-babel-C-expand-C++ body params))
	    (d   (org-babel-C-expand-D   body params)))))
    (with-temp-file tmp-src-file (insert full-body))
    (case org-babel-c-variant
      ((c cpp)
       (org-babel-eval
	(format "%s -o %s %s %s"
		(case org-babel-c-variant
		 (c   org-babel-C-compiler)
		 (cpp org-babel-C++-compiler))
		(org-babel-process-file-name tmp-bin-file)
		flags
		(org-babel-process-file-name tmp-src-file)) ""))
      (d nil)) ;; no separate compilation for D
    (let ((results
	   (org-babel-eval
	    (case org-babel-c-variant
	      ((c cpp)
	       (concat tmp-bin-file cmdline))
	      (d
	       (format "%s %s %s %s"
		       org-babel-D-compiler
		       flags
		       (org-babel-process-file-name tmp-src-file)
		       cmdline)))
	    "")))
      (when results
	(setq results (org-babel-trim (org-remove-indentation results)))
	(org-babel-reassemble-table
	 (org-babel-result-cond (cdr (assoc :result-params params))
	   (org-babel-read results t)
	   (let ((tmp-file (org-babel-temp-file "c-")))
	     (with-temp-file tmp-file (insert results))
	     (org-babel-import-elisp-from-file tmp-file)))
	 (org-babel-pick-name
	  (cdr (assoc :colname-names params)) (cdr (assoc :colnames params)))
	 (org-babel-pick-name
	  (cdr (assoc :rowname-names params)) (cdr (assoc :rownames params)))))
      )))

(defun org-babel-expand-body:C++ (body params)
  "Expand a block of C++ code with org-babel according to it's
header arguments."
  (let ((org-babel-c-variant 'cpp)) (org-babel-C-expand-C++ body params)))

(defun org-babel-expand-body:C (body params)
  "Expand a block of C code with org-babel according to it's
header arguments."
  (let ((org-babel-c-variant 'c)) (org-babel-C-expand-C body params)))

(defun org-babel-expand-body:D (body params)
  "Expand a block of D code with org-babel according to it's
header arguments."
  (let ((org-babel-c-variant 'd)) (org-babel-C-expand-D body params)))

(defun org-babel-C-expand-C++ (body params)
  "Expand a block of C or C++ code with org-babel according to
it's header arguments."
  (org-babel-C-expand-C body params))

(defun org-babel-C-expand-C (body params)
  "Expand a block of C or C++ code with org-babel according to
it's header arguments."
  (let ((vars (mapcar #'cdr (org-babel-get-header params :var)))
	(colnames (cdar (org-babel-get-header params :colname-names)))
	(main-p (not (string= (cdr (assoc :main params)) "no")))
	(includes (or (cdr (assoc :includes params))
		      (org-babel-read (org-entry-get nil "includes" t))))
	(defines (org-babel-read
		  (or (cdr (assoc :defines params))
		      (org-babel-read (org-entry-get nil "defines" t))))))
    (unless (listp includes) (setq includes (list includes)))
    (setq includes (append includes '("<string.h>" "<stdio.h>" "<stdlib.h>")))
    (mapconcat 'identity
	       (list
		;; includes
		(mapconcat
		 (lambda (inc) (format "#include %s" inc))
		 includes "\n")
		;; defines
		(mapconcat
		 (lambda (inc) (format "#define %s" inc))
		 (if (listp defines) defines (list defines)) "\n")
		;; variables
		(mapconcat 'org-babel-C-var-to-C vars "\n")
		;; table sizes
		(mapconcat 'org-babel-C-table-sizes-to-C vars "\n")
		;; tables headers utility
		(when colnames
		  (org-babel-C-utility-header-to-C))
		;; tables headers
		(mapconcat 'org-babel-C-header-to-C colnames "\n")
		;; body
		(if main-p
		    (org-babel-C-ensure-main-wrap body)
		  body) "\n") "\n")))

(defun org-babel-C-expand-D (body params)
  "Expand a block of D code with org-babel according to
it's header arguments."
  (let ((vars (mapcar #'cdr (org-babel-get-header params :var)))
	(colnames (cdar (org-babel-get-header params :colname-names)))
	(main-p (not (string= (cdr (assoc :main params)) "no")))
	(imports (or (cdr (assoc :imports params))
		     (org-babel-read (org-entry-get nil "imports" t)))))
    (unless (listp imports) (setq imports (list imports)))
    (setq imports (append imports '("std.stdio" "std.conv")))
    (mapconcat 'identity
	       (list
		"module mmm;"
		;; imports
		(mapconcat
		 (lambda (inc) (format "import %s;" inc))
		 imports "\n")
		;; variables
		(mapconcat 'org-babel-C-var-to-C vars "\n")
		;; table sizes
		(mapconcat 'org-babel-C-table-sizes-to-C vars "\n")
		;; tables headers utility
		(when colnames
		  (org-babel-C-utility-header-to-C))
		;; tables headers
		(mapconcat 'org-babel-C-header-to-C colnames "\n")
		;; body
		(if main-p
		    (org-babel-C-ensure-main-wrap body)
		  body) "\n") "\n")))

(defun org-babel-C-ensure-main-wrap (body)
  "Wrap BODY in a \"main\" function call if none exists."
  (if (string-match "^[ \t]*[intvod]+[ \t\n\r]*main[ \t]*(.*)" body)
      body
    (format "int main() {\n%s\nreturn 0;\n}\n" body)))

(defun org-babel-prep-session:C (session params)
  "This function does nothing as C is a compiled language with no
support for sessions"
  (error "C is a compiled languages -- no support for sessions"))

(defun org-babel-load-session:C (session body params)
  "This function does nothing as C is a compiled language with no
support for sessions"
  (error "C is a compiled languages -- no support for sessions"))

;; helper functions

(defun org-babel-C-format-val (type val)
  "Handle the FORMAT part of TYPE with the data from VAL."
  (let ((format-data (cadr type)))
    (if (stringp format-data)
	(cons "" (format format-data val))
      (funcall format-data val))))

(defun org-babel-C-val-to-base-type (val)
  "Determine the base type of VAL which may be
'integerp if all base values are integers
'floatp if all base values are either floating points or integers
'stringp otherwise."
  (cond
   ((integerp val) 'integerp)
   ((floatp val) 'floatp)
   ((or (listp val) (vectorp val))
    (let ((type nil))
      (mapc (lambda (v)
	      (case (org-babel-C-val-to-base-type v)
		(stringp (setq type 'stringp))
		(floatp
		 (if (or (not type) (eq type 'integerp))
		     (setq type 'floatp)))
		(integerp
		 (unless type (setq type 'integerp)))))
	    val)
      type))
   (t 'stringp)))

(defun org-babel-C-val-to-C-type (val)
  "Determine the type of VAL.
Return a list (TYPE-NAME FORMAT).  TYPE-NAME should be the name of the type.
FORMAT can be either a format string or a function which is called with VAL."
  (let* ((basetype (org-babel-C-val-to-base-type val))
	 (type
	  (case basetype
	    (integerp '("int" "%d"))
	    (floatp '("double" "%f"))
	    (stringp
	     (list
	      (if (equal org-babel-c-variant 'd) "string" "const char*")
	      "\"%s\""))
	    (t (error "unknown type %S" type)))))
    (cond
     ((integerp val) type) ;; an integer declared in the #+begin_src line
     ((floatp val) type) ;; a numeric declared in the #+begin_src line
     ((and (listp val) (listp (car val))) ;; a table
      `(,(car type)
	(lambda (val)
	  (cons
	   (format "[%d][%d]" (length val) (length (car val)))
	   (concat
	    (if (equal org-babel-c-variant 'd) "[\n" "{\n")
	    (mapconcat
	     (lambda (v)
	       (concat
		(if (equal org-babel-c-variant 'd) " [" " {")
		(mapconcat (lambda (w) (format ,(cadr type) w)) v ",")
		(if (equal org-babel-c-variant 'd) "]" "}")))
	     val
	     ",\n")
	    (if (equal org-babel-c-variant 'd) "\n]" "\n}"))))))
     ((or (listp val) (vectorp val)) ;; a list declared in the #+begin_src line
      `(,(car type)
	(lambda (val)
	  (cons
	   (format "[%d]" (length val))
	   (concat
	    (if (equal org-babel-c-variant 'd) "[" "{")
	    (mapconcat (lambda (v) (format ,(cadr type) v)) val ",")
	    (if (equal org-babel-c-variant 'd) "]" "}"))))))
     (t ;; treat unknown types as string
      type))))

(defun org-babel-C-var-to-C (pair)
  "Convert an elisp val into a string of C code specifying a var
of the same value."
  ;; TODO list support
  (let ((var (car pair))
	(val (cdr pair)))
    (when (symbolp val)
      (setq val (symbol-name val))
      (when (= (length val) 1)
	(setq val (string-to-char val))))
    (let* ((type-data (org-babel-C-val-to-C-type val))
	   (type (car type-data))
	   (formated (org-babel-C-format-val type-data val))
	   (suffix (car formated))
	   (data (cdr formated)))
      (format "%s %s%s = %s;"
	      type
	      var
	      suffix
	      data))))

(defun org-babel-C-table-sizes-to-C (pair)
  "Create constants of table dimensions, if PAIR is a table."
  (when (listp (cdr pair))
    (cond
     ((listp (cadr pair)) ;; a table
      (concat
       (format "const int %s_rows = %d;" (car pair) (length (cdr pair)))
       "\n"
       (format "const int %s_cols = %d;" (car pair) (length (cadr pair)))))
     (t ;; a list declared in the #+begin_src line
      (format "const int %s_cols = %d;" (car pair) (length (cdr pair)))))))

(defun org-babel-C-utility-header-to-C ()
  "Generate a utility function to convert a column name
into a column number."
  (case org-babel-c-variant
    ((c cpp)
     "int get_column_num (int nbcols, const char** header, const char* column)
{
  int c;
  for (c=0; c<nbcols; c++)
    if (strcmp(header[c],column)==0)
      return c;
  return -1;
}
"
     )
    (d
     "int get_column_num (string[] header, string column)
{
  foreach (c, h; header)
    if (h==column)
      return to!int(c);
  return -1;
}
"
     )))

(defun org-babel-C-header-to-C (head)
  "Convert an elisp list of header table into a C or D vector
specifying a variable with the name of the table."
  (let ((table (car head))
        (headers (cdr head)))
    (concat
     (format
      (case org-babel-c-variant
	((c cpp) "const char* %s_header[%d] = {%s};")
	(d       "string %s_header[%d] = [%s];"))
      table
      (length headers)
      (mapconcat (lambda (h) (format "%S" h)) headers ","))
     "\n"
     (case org-babel-c-variant
       ((c cpp)
	(format
	 "const char* %s_h (int row, const char* col) { return %s[row][get_column_num(%d,%s_header,col)]; }"
	 table table (length headers) table))
       (d
	(format
	 "string %s_h (ulong row, string col) { return %s[row][get_column_num(%s_header,col)]; }"
	 table table table))))))

(provide 'ob-C)

;;; ob-C.el ends here

#+END_SRC
