#+OPTIONS:    H:3 num:nil toc:2 \n:nil ::t |:t ^:{} -:t f:t *:t tex:t d:(HIDE) tags:not-in-toc
#+STARTUP:    align fold nodlcheck hidestars oddeven lognotestate hideblocks
#+SEQ_TODO:   TODO(t) INPROGRESS(i) WAITING(w@) | DONE(d) CANCELED(c@)
#+TAGS:       Write(w) Update(u) Fix(f) Check(c) noexport(n)
#+TITLE:      D Source Code Blocks in Org Mode
#+AUTHOR:     Thierry Banel
#+EMAIL:      tbanelwebmin[at]free[dot]fr
#+LANGUAGE:   en
#+HTML_HEAD:      <style type="text/css">#outline-container-introduction{ clear:both; }</style>
#+LINK_UP:    ../languages.html
#+LINK_HOME:  http://orgmode.org/worg/
#+EXCLUDE_TAGS: noexport

#+name: banner
#+begin_html
  <div id="subtitle" style="float: center; text-align: center;">
  <p>
  Org Mode support for <a href="http://dlang.org/">D</a>
  </p>
  <p>
  <a href="http://dlang.org/">
  <img src="http://dlang.org/images/dlogo.png"/>
  </a>
  </p>
  </div>
#+end_html

* Template Checklist [12/12] 					   :noexport:
  - [X] Revise #+TITLE:
  - [X] Indicate #+AUTHOR:
  - [X] Add #+EMAIL:
  - [X] Revise banner source block [3/3]
    - [X] Add link to a useful language web site
    - [X] Replace "Language" with language name
    - [X] Find a suitable graphic and use it to link to the language
      web site
  - [X] Write an [[Introduction]]
  - [X] Describe [[Requirements%20and%20Setup][Requirements and Setup]]
  - [X] Replace "Language" with language name in [[Org%20Mode%20Features%20for%20Language%20Source%20Code%20Blocks][Org Mode Features for Language Source Code Blocks]]
  - [X] Describe [[Header%20Arguments][Header Arguments]]
  - [X] Describe support for [[Sessions]]
  - [X] Describe [[Result%20Types][Result Types]]
  - [X] Describe [[Other]] differences from supported languages
  - [X] Provide brief [[Examples%20of%20Use][Examples of Use]]
* Introduction
[[http://dlang.org/][D]] is a C++-like language made by [[http://dlang.org/][Digital Mars]].
It features:
  - C++ syntax
  - Built-in garbage collector
  - Strong type system
  - Meta-programming
  - Seamless assembler support
  - Usable as a scripting language
  - C binary compatibility
  - and much more.

The scripting feature of [[http://dlang.org/][D]] is leveraged in Org mode.
Basically, we call [[http://dlang.org/rdmd.html][=rdmd=]] instead of the =dmd= compiler.
This transparently compiles, caches, and run the script.

D may be used like many other script languages (Perl, Awk, Emacs Lisp,
etc.) to process data within Org files, without worrying about memory
management, with the help of a strong type system, and enjoying the
speed of a compiled language.

* Requirements and Setup

  1. The D runtime must be installed on your platform.
   Look at http://dlang.org/ for downloading and instructions.
   Eventually, the =dmd= and =rdmd= compilers must be in the =PATH=.
   A separate =d-mode.el= package is available, for syntax higlighting.
   It is not required.

  2. Add =ob-D.el= in the =lisp/org/= source tree.
   For now, this file is attached at the end of this page.

  3. In the =org.el= file, find a line which says:
                : (const :tag "C" C)
   add a similar line for D:
  		: (const :tag "D" D)

  4. byte-compile the 2 modified =*.el=

  5. customize the variable =org-babel-load-languages= enabling D
     - either through =M-x customize-variable=
     (you may need a restart of Emacs prior to customization)
     - or in your =.emacs=

* Org Mode Features for D Source Code Blocks
** Header Arguments
  - =:results output= ::
    (only output presently)
  - =:var VARIABLE=VALUE= ::
    A global D variable named VARIABLE will be declared
    and initialized with VALUE
    Possible types for VARIABLE may be:
      : int, double, string, string[][]
    The later type, =string[][]=, is used for variables storing
    Org tables
  - =:import package= ::
    An import statement will be declared in the D source
    before the source code

** Sessions
   There is no support for sessions

** Result Types
   Presently, only output result is supported
   =:results output=

** Other
   D support is quite similar to C and C++ support.

   One difference though, is that in D compilation is cached. Only
   the first run incures compile time, up to the next change in the
   source.

* Examples of Use
** Hello World
Here is Hello World!

#+name: d-hello
#+begin_src D :exports results
  import std.stdio;
  writefln ("Hello World!");
#+end_src

This source code block:

#+begin_example
#+begin_src D
   import std.stdio;
   writefln ("Hello World!");
#+end_src
#+end_example

yields this result:

#+results: d-hello
Hello World!

** Process an Org Mode Table
We take an Org mode table as input, process it, and output
a new Org mode table.

This table will be input in the D script, and iterated row by row:

#+tblname: somedata
| nb | sqr | noise |
|----+-----+-------|
|  0 |   0 |  0.23 |
|  1 |   1 |  1.31 |
|  2 |   4 |  4.61 |
|  3 |   9 |  9.05 |
|  4 |  16 | 16.55 |

#+name: d-table
#+header: :exports results
#+begin_src D :results output :var somedata=somedata :var TT="321" :var QQ=3.14
  import std.stdio;
  import std.conv;

  void main()
  {
    foreach (i, row; somedata) {
      writef ("|%2s ", i);
      foreach (cell; row)
        writef ("| %5s | %5s ", cell, 1000*to!real(cell));
      writefln ("| %7s |", to!real(TT)*to!real(QQ));
    }
  }
#+end_src

#+begin_example
#+begin_src D :results output :var somedata=somedata :var TT="321" :var QQ=3.14
  import std.stdio;
  import std.conv;

  void main()
  {
    foreach (i, row; somedata) {
      writef ("|%2s ", i);
      foreach (cell; row)
        writef ("| %5s | %5s ", cell, 1000*to!real(cell));
      writefln ("| %7s |", to!real(TT)*to!real(QQ));
    }
  }
#+end_src
#+end_example

yields this result:

#+results: d-table
| 0 | 0 |    0 |  0 |     0 |  0.23 |   230 | 1007.94 |
| 1 | 1 | 1000 |  1 |  1000 |  1.31 |  1310 | 1007.94 |
| 2 | 2 | 2000 |  4 |  4000 |  4.61 |  4610 | 1007.94 |
| 3 | 3 | 3000 |  9 |  9000 |  9.05 |  9050 | 1007.94 |
| 4 | 4 | 4000 | 16 | 16000 | 16.55 | 16550 | 1007.94 |

* Source file
http://orgmode.org/cgit.cgi/org-mode.git/plain/contrib/lisp/ob-D.el
* Mixed C, C++, D source file

C, C++, and D are quite similar languages.
Thus, it make sense to merge all in a single, easy to maintain, lisp source file.
Here it is.

#+BEGIN_SRC elisp
  ;;; ob-C.el --- org-babel functions for C and similar languages
  
  ;; Copyright (C) 2010-2013 Free Software Foundation, Inc.
  
  ;; Author: Eric Schulte, Thierry Banel
  ;; Keywords: literate programming, reproducible research
  ;; Homepage: http://orgmode.org
  
  ;; This file is part of GNU Emacs.
  
  ;; GNU Emacs is free software: you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation, either version 3 of the License, or
  ;; (at your option) any later version.
  
  ;; GNU Emacs is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.
  
  ;; You should have received a copy of the GNU General Public License
  ;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.
  
  ;;; Commentary:
  
  ;; Org-Babel support for evaluating C, C++, D code.
  ;;
  ;; very limited implementation:
  ;; - currently only support :results output
  ;; - not much in the way of error feedback
  
  ;;; Code:
  (require 'ob)
  (require 'cc-mode)
  (eval-when-compile
    (require 'cl))
  
  (declare-function org-entry-get "org"
                    (pom property &optional inherit literal-nil))
  (declare-function org-remove-indentation "org" (code &optional n))
  
  (defvar org-babel-tangle-lang-exts)
  (add-to-list 'org-babel-tangle-lang-exts '("C++" . "cpp"))
  (add-to-list 'org-babel-tangle-lang-exts '("D" . "d"))
  
  (defvar org-babel-default-header-args:C '())
  
  (defvar org-babel-C-compiler "gcc"
    "Command used to compile a C source code file into an
  executable.")
  
  (defvar org-babel-C++-compiler "g++"
    "Command used to compile a C++ source code file into an
  executable.")
  
  (defvar org-babel-D-compiler "rdmd"
    "Command used to compile and execute a D source code file.")
  
  (defvar org-babel-c-variant nil
    "Internal variable used to hold which type of C (e.g. C or C++ or D)
  is currently being evaluated.")
  
  (defun org-babel-execute:cpp (body params)
    "Execute BODY according to PARAMS.
  This function calls `org-babel-execute:C++'."
    (org-babel-execute:C++ body params))
  
  (defun org-babel-execute:C++ (body params)
    "Execute a block of C++ code with org-babel.
  This function is called by `org-babel-execute-src-block'."
    (let ((org-babel-c-variant 'cpp)) (org-babel-C-execute body params)))
  
  ;;(defun org-babel-expand-body:C++ (body params) ;; unused
  ;;  "Expand a block of C++ code with org-babel according to it's
  ;;header arguments (calls `org-babel-C-expand')."
  ;;  (let ((org-babel-c-variant 'cpp)) (org-babel-C-expand body params)))
  
  (defun org-babel-execute:D (body params)
    "Execute a block of D code with org-babel.
  This function is called by `org-babel-execute-src-block'."
    (let ((org-babel-c-variant 'd)) (org-babel-C-execute body params)))
  
  ;; (defun org-babel-expand-body:D (body params) ;; unused
  ;;  "Expand a block of D code with org-babel according to it's
  ;;header arguments (calls `org-babel-C-expand')."
  ;;  (let ((org-babel-c-variant 'd)) (org-babel-C-expand body params)))
  
  (defun org-babel-execute:C (body params)
    "Execute a block of C code with org-babel.
  This function is called by `org-babel-execute-src-block'."
    (let ((org-babel-c-variant 'c)) (org-babel-C-execute body params)))
  
  ;; (defun org-babel-expand-body:c (body params) ;; unused
  ;;  "Expand a block of C code with org-babel according to it's
  ;;header arguments (calls `org-babel-C-expand')."
  ;;  (let ((org-babel-c-variant 'c)) (org-babel-C-expand body params)))
  
  (defun org-babel-C-execute (body params)
    "This function should only be called by `org-babel-execute:C'
  or `org-babel-execute:C++' or `org-babel-execute:D'."
    (let* ((tmp-src-file (org-babel-temp-file
                          "C-src-"
                          (cond
                           ((equal org-babel-c-variant 'c  ) ".c"  )
                           ((equal org-babel-c-variant 'cpp) ".cpp")
                           ((equal org-babel-c-variant 'd  ) ".d"  ))))
           (tmp-bin-file (org-babel-temp-file "C-bin-" org-babel-exeext)) ;; not used for D
           (cmdline (cdr (assoc :cmdline params)))
           (cmdline (if cmdline (concat " " cmdline) ""))
           (flags (cdr (assoc :flags params)))
           (flags (mapconcat 'identity
                             (if (listp flags) flags (list flags)) " "))
           (full-body
            (cond ((equal org-babel-c-variant 'c  ) (org-babel-C-expand-C   body params))
                  ((equal org-babel-c-variant 'cpp) (org-babel-C-expand-C++ body params))
                  ((equal org-babel-c-variant 'd  ) (org-babel-C-expand-D   body params)))))
      (with-temp-file tmp-src-file (insert full-body))
      (if (memq org-babel-c-variant '(c cpp)) ;; no separate compilation for D
          (org-babel-eval
           (format "%s -o %s %s %s"
                   (cond
                    ((equal org-babel-c-variant 'c  ) org-babel-C-compiler)
                    ((equal org-babel-c-variant 'cpp) org-babel-C++-compiler))
                   (org-babel-process-file-name tmp-bin-file)
                   flags
                   (org-babel-process-file-name tmp-src-file)) ""))
      (let ((results
             (org-babel-trim
              (org-remove-indentation
               (org-babel-eval
                (cond ((memq org-babel-c-variant '(c cpp))
                       (concat tmp-bin-file cmdline))
                      ((equal org-babel-c-variant 'd)
                       (format "%s %s %s %s"
                               org-babel-D-compiler
                               flags
                               (org-babel-process-file-name tmp-src-file)
                               cmdline)))
                "")))))
        (org-babel-reassemble-table
         (org-babel-result-cond (cdr (assoc :result-params params))
           (org-babel-read results t)
           (let ((tmp-file (org-babel-temp-file "c-")))
             (with-temp-file tmp-file (insert results))
             (org-babel-import-elisp-from-file tmp-file)))
         (org-babel-pick-name
          (cdr (assoc :colname-names params)) (cdr (assoc :colnames params)))
         (org-babel-pick-name
          (cdr (assoc :rowname-names params)) (cdr (assoc :rownames params)))))
      ))
  
  (defun org-babel-C-expand-C++ (body params)
    "Expand a block of C or C++ code with org-babel according to
  it's header arguments."
    (org-babel-C-expand-C body params))
  
  (defun org-babel-C-expand-C (body params)
    "Expand a block of C or C++ code with org-babel according to
  it's header arguments."
    (let ((vars (mapcar #'cdr (org-babel-get-header params :var)))
          (main-p (not (string= (cdr (assoc :main params)) "no")))
          (includes (or (cdr (assoc :includes params))
                        (org-babel-read (org-entry-get nil "includes" t))))
          (defines (org-babel-read
                    (or (cdr (assoc :defines params))
                        (org-babel-read (org-entry-get nil "defines" t))))))
      (mapconcat 'identity
                 (list
                  ;; includes
                  (mapconcat
                   (lambda (inc) (format "#include %s" inc))
                   (if (listp includes) includes (list includes)) "\n")
                  ;; defines
                  (mapconcat
                   (lambda (inc) (format "#define %s" inc))
                   (if (listp defines) defines (list defines)) "\n")
                  ;; variables
                  (mapconcat 'org-babel-C-var-to-C vars "\n")
                  ;; body
                  (if main-p
                      (org-babel-C-ensure-main-wrap body)
                    body) "\n") "\n")))
  
  (defun org-babel-C-expand-D (body params)
    "Expand a block of D code with org-babel according to
  it's header arguments."
    (let ((vars (mapcar #'cdr (org-babel-get-header params :var)))
          (main-p (not (string= (cdr (assoc :main params)) "no")))
          (imports (or (cdr (assoc :imports params))
                       (org-babel-read (org-entry-get nil "imports" t)))))
      (mapconcat 'identity
                 (list
                  "module mmm;"
                  ;; imports
                  (mapconcat
                   (lambda (inc) (format "import %s;" inc))
                   (if (listp imports) imports (list imports)) "\n")
                  ;; variables
                  (mapconcat 'org-babel-C-var-to-C vars "\n")
                  ;; body
                  (if main-p
                      (org-babel-C-ensure-main-wrap body)
                    body) "\n") "\n")))
  
  (defun org-babel-C-ensure-main-wrap (body)
    "Wrap BODY in a \"main\" function call if none exists."
    (if (string-match "^[ \t]*[intvod]+[ \t\n\r]*main[ \t]*(.*)" body)
        body
      (format "int main() {\n%s\nreturn 0;\n}\n" body)))
  
  (defun org-babel-prep-session:C (session params)
    "This function does nothing as C is a compiled language with no
  support for sessions"
    (error "C is a compiled languages -- no support for sessions"))
  
  (defun org-babel-load-session:C (session body params)
    "This function does nothing as C is a compiled language with no
  support for sessions"
    (error "C is a compiled languages -- no support for sessions"))
  
  ;; helper functions
  
  (defun org-babel-C-format-val (type val)
    "Handle the FORMAT part of TYPE with the data from VAL."
    (let ((format-data (cadr type)))
      (if (stringp format-data)
          (cons "" (format format-data val))
        (funcall format-data val))))
  
  (defun org-babel-C-val-to-C-type (val)
    "Determine the type of VAL.
  Return a list (TYPE-NAME FORMAT).  TYPE-NAME should be the name of the type.
  FORMAT can be either a format string or a function which is called with VAL."
    (cond
     ((integerp val) '("int" "%d"))
     ((floatp val) '("double" "%f"))
     ((or (listp val) (vectorp val))
      (lexical-let ((type (org-babel-C-val-to-C-list-type val)))
        (list (car type)
              (lambda (val)
                (cons
                 (format "[%d]%s"
                         (length val)
                         (car (org-babel-C-format-val type (elt val 0))))
                 (concat (if (equal org-babel-c-variant 'd) "[ " "{ ")
                         (mapconcat (lambda (v)
                                      (cdr (org-babel-C-format-val type v)))
                                    val
                                    ", ")
                         (if (equal org-babel-c-variant 'd) " ]" " }")))))))
     (t ;; treat unknown types as string
      (list
       (if (equal org-babel-c-variant 'd) "string" "const char*")
       "\"%s\""))))
  
  (defun org-babel-C-val-to-C-list-type (val)
    "Determine the C array type of a VAL."
    (let (type)
      (mapc
       #'(lambda (i)
           (let* ((tmp-type (org-babel-C-val-to-C-type i))
                  (type-name (car type))
                  (tmp-type-name (car tmp-type)))
             (when (and type (not (string= type-name tmp-type-name)))
               (if (and (member type-name '("int" "double" "int32_t"))
                        (member tmp-type-name '("int" "double" "int32_t")))
                   (setq tmp-type '("double" "" "%f"))
                 (error "Only homogeneous lists are supported by C.  You can not mix %s and %s"
                        type-name
                        tmp-type-name)))
             (setq type tmp-type)))
       val)
      type))
  
  (defun org-babel-C-var-to-C (pair)
    "Convert an elisp val into a string of C code specifying a var
  of the same value."
    ;; TODO list support
    (let ((var (car pair))
          (val (cdr pair)))
      (when (symbolp val)
        (setq val (symbol-name val))
        (when (= (length val) 1)
          (setq val (string-to-char val))))
      (let* ((type-data (org-babel-C-val-to-C-type val))
             (type (car type-data))
             (formated (org-babel-C-format-val type-data val))
             (suffix (car formated))
             (data (cdr formated)))
        (format "%s %s%s = %s;"
                type
                var
                suffix
                data))))
  
  (provide 'ob-C)
  
  ;;; ob-C.el ends here
  
#+END_SRC
